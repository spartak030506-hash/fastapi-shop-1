# Security

Документация по безопасности проекта, аутентификации и защите данных.

---

## Общие принципы

Безопасность реализована как отдельный слой и не размазана по приложению.

**Ключевые принципы:**
- аутентификация через JWT
- refresh tokens с ротацией
- отсутствие хранения plaintext токенов
- проверка состояния пользователя на каждом шаге
- минимизация информации, доступной клиенту

---

## JWT архитектура

### Access Token
- короткоживущий
- используется для авторизации запросов
- передаётся в `Authorization: Bearer <token>`

### Refresh Token
- долгоживущий
- используется только для получения новой пары токенов
- **не используется для доступа к API**

---

## Двойной секрет для JWT

Используются **два разных секрета**:
- `JWT_ACCESS_SECRET`
- `JWT_REFRESH_SECRET`

✅ Компрометация одного токена не ломает всю систему  
✅ Упрощает отзыв refresh токенов  

---

## Хранение refresh токенов

В БД **НИКОГДА** не хранится сам refresh токен.

Хранится:
- SHA-256 хеш токена
- user_id
- device_info
- expires_at

```python
token_hash = sha256(refresh_token.encode()).hexdigest()
```

✅ Даже при утечке БД токены не могут быть использованы

## Token rotation

При каждом refresh:

- старый refresh токен отзывается
- создаётся новая пара access + refresh
- предыдущий токен больше невалиден

✅ Защита от replay-атак  
✅ Безопасная работа с несколькими устройствами

## Проверка JWT payload

Перед использованием refresh токена выполняются проверки:

- payload существует
- sub присутствует
- sub не равен None
- sub является UUID
- UUID валиден

```python
if (
    not payload.sub
    or not isinstance(payload.sub, UUID)
):
    raise InvalidTokenError()
```

✅ Защита от malformed JWT  
✅ Защита от атак через поддельные payload

## Проверка состояния пользователя

Перед выдачей новых токенов:

- пользователь существует
- is_active == True
- is_deleted == False

❌ Заблокированные и удалённые пользователи не получают доступ

## Отзыв токенов

### Logout
- отзывает один refresh токен

### Logout all devices
- отзывает все refresh токены пользователя

Это позволяет:

- завершать сессии выборочно
- принудительно разлогинивать пользователя

## Смена пароля

При смене пароля:

- проверяется старый пароль
- пароль хешируется через bcrypt
- отзываются все refresh токены пользователя

✅ Украденные токены становятся бесполезными

## Soft delete пользователя

При удалении пользователя:

- устанавливается is_deleted = True
- пользователь теряет доступ
- все refresh токены отзываются

❌ Логин и refresh невозможны

## Хеширование паролей

Используется:

```
bcrypt
```

Принципы:

- соль генерируется автоматически
- plaintext пароль никогда не хранится
- сравнение выполняется через bcrypt.checkpw

## Защита от brute-force

Реализуется косвенно:

- короткое TTL access токенов
- обязательная проверка refresh токенов
- отзыв токенов при смене пароля

(Rate limiting может быть добавлен при необходимости)

## IntegrityError и безопасность

Race conditions закрываются за счёт обработки ошибок БД:

```python
except IntegrityError:
    raise EmailAlreadyExistsError()
```

✅ Злоумышленник не может создать дубликаты  
✅ Поведение системы предсказуемо

## Изоляция секретов

Секретные данные:

- JWT secrets
- DB credentials

Хранятся:

- в .env
- загружаются через pydantic-settings

❌ Секреты не хранятся в коде  
❌ Секреты не логируются

## Exception handling

Все security-ошибки:

- приводятся к доменным исключениям
- отдаются клиенту с корректным HTTP status

✅ Нет утечки внутренней информации  
✅ Ошибки единообразны